# Ruby-SDL3 : SDL3 wrapper for Ruby
#
# * https://github.com/vaiorabbit/sdl3-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module SDL
  extend FFI::Library
  # Define/Macro


  # Enum

  ASYNCIO_TASK_READ = 0
  ASYNCIO_TASK_WRITE = 1
  ASYNCIO_TASK_CLOSE = 2
  ASYNCIO_COMPLETE = 0
  ASYNCIO_FAILURE = 1
  ASYNCIO_CANCELED = 2

  # Typedef

  typedef :int, :SDL_AsyncIOTaskType
  typedef :int, :SDL_AsyncIOResult

  # Struct

  class AsyncIOOutcome < FFI::Struct
    layout(
      :asyncio, :pointer,
      :type, :int,
      :result, :int,
      :buffer, :pointer,
      :offset, :ulong_long,
      :bytes_requested, :ulong_long,
      :bytes_transferred, :ulong_long,
      :userdata, :pointer,
    )
  end


  # Function

  def self.setup_asyncio_symbols(output_error = false)
    symbols = [
      :SDL_AsyncIOFromFile,
      :SDL_GetAsyncIOSize,
      :SDL_ReadAsyncIO,
      :SDL_WriteAsyncIO,
      :SDL_CloseAsyncIO,
      :SDL_CreateAsyncIOQueue,
      :SDL_DestroyAsyncIOQueue,
      :SDL_GetAsyncIOResult,
      :SDL_WaitAsyncIOResult,
      :SDL_SignalAsyncIOQueue,
      :SDL_LoadFileAsync,
    ]
    apis = {
      :SDL_AsyncIOFromFile => :AsyncIOFromFile,
      :SDL_GetAsyncIOSize => :GetAsyncIOSize,
      :SDL_ReadAsyncIO => :ReadAsyncIO,
      :SDL_WriteAsyncIO => :WriteAsyncIO,
      :SDL_CloseAsyncIO => :CloseAsyncIO,
      :SDL_CreateAsyncIOQueue => :CreateAsyncIOQueue,
      :SDL_DestroyAsyncIOQueue => :DestroyAsyncIOQueue,
      :SDL_GetAsyncIOResult => :GetAsyncIOResult,
      :SDL_WaitAsyncIOResult => :WaitAsyncIOResult,
      :SDL_SignalAsyncIOQueue => :SignalAsyncIOQueue,
      :SDL_LoadFileAsync => :LoadFileAsync,
    }
    args = {
      :SDL_AsyncIOFromFile => [:pointer, :pointer],
      :SDL_GetAsyncIOSize => [:pointer],
      :SDL_ReadAsyncIO => [:pointer, :pointer, :ulong_long, :ulong_long, :pointer, :pointer],
      :SDL_WriteAsyncIO => [:pointer, :pointer, :ulong_long, :ulong_long, :pointer, :pointer],
      :SDL_CloseAsyncIO => [:pointer, :bool, :pointer, :pointer],
      :SDL_CreateAsyncIOQueue => [],
      :SDL_DestroyAsyncIOQueue => [:pointer],
      :SDL_GetAsyncIOResult => [:pointer, :pointer],
      :SDL_WaitAsyncIOResult => [:pointer, :pointer, :int],
      :SDL_SignalAsyncIOQueue => [:pointer],
      :SDL_LoadFileAsync => [:pointer, :pointer, :pointer],
    }
    retvals = {
      :SDL_AsyncIOFromFile => :pointer,
      :SDL_GetAsyncIOSize => :long_long,
      :SDL_ReadAsyncIO => :bool,
      :SDL_WriteAsyncIO => :bool,
      :SDL_CloseAsyncIO => :bool,
      :SDL_CreateAsyncIOQueue => :pointer,
      :SDL_DestroyAsyncIOQueue => :void,
      :SDL_GetAsyncIOResult => :bool,
      :SDL_WaitAsyncIOResult => :bool,
      :SDL_SignalAsyncIOQueue => :void,
      :SDL_LoadFileAsync => :bool,
    }
    symbols.each do |sym|
      begin
        attach_function apis[sym], sym, args[sym], retvals[sym]
      rescue FFI::NotFoundError => error
        $stderr.puts("[Warning] Failed to import #{sym} (#{error}).") if output_error
      end
    end
  end

end

