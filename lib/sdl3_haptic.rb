# Ruby-SDL3 : SDL3 wrapper for Ruby
#
# * https://github.com/vaiorabbit/sdl3-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module SDL
  extend FFI::Library
  # Define/Macro

  HAPTIC_CONSTANT = 1 << 0
  HAPTIC_SINE = 1 << 1
  HAPTIC_SQUARE = 1 << 2
  HAPTIC_TRIANGLE = 1 << 3
  HAPTIC_SAWTOOTHUP = 1 << 4
  HAPTIC_SAWTOOTHDOWN = 1 << 5
  HAPTIC_RAMP = 1 << 6
  HAPTIC_SPRING = 1 << 7
  HAPTIC_DAMPER = 1 << 8
  HAPTIC_INERTIA = 1 << 9
  HAPTIC_FRICTION = 1 << 10
  HAPTIC_LEFTRIGHT = 1 << 11
  HAPTIC_RESERVED1 = 1 << 12
  HAPTIC_RESERVED2 = 1 << 13
  HAPTIC_RESERVED3 = 1 << 14
  HAPTIC_CUSTOM = 1 << 15
  HAPTIC_GAIN = 1 << 16
  HAPTIC_AUTOCENTER = 1 << 17
  HAPTIC_STATUS = 1 << 18
  HAPTIC_PAUSE = 1 << 19
  HAPTIC_POLAR = 0
  HAPTIC_CARTESIAN = 1
  HAPTIC_SPHERICAL = 2
  HAPTIC_STEERING_AXIS = 3
  HAPTIC_INFINITY = 4294967295

  # Enum


  # Typedef

  typedef :uint, :SDL_HapticID

  # Struct

  class HapticDirection < FFI::Struct
    layout(
      :type, :uchar,
      :dir, [:int, 3],
    )
  end

  class HapticConstant < FFI::Struct
    layout(
      :type, :ushort,
      :direction, HapticDirection,
      :length, :uint,
      :delay, :ushort,
      :button, :ushort,
      :interval, :ushort,
      :level, :short,
      :attack_length, :ushort,
      :attack_level, :ushort,
      :fade_length, :ushort,
      :fade_level, :ushort,
    )
  end

  class HapticPeriodic < FFI::Struct
    layout(
      :type, :ushort,
      :direction, HapticDirection,
      :length, :uint,
      :delay, :ushort,
      :button, :ushort,
      :interval, :ushort,
      :period, :ushort,
      :magnitude, :short,
      :offset, :short,
      :phase, :ushort,
      :attack_length, :ushort,
      :attack_level, :ushort,
      :fade_length, :ushort,
      :fade_level, :ushort,
    )
  end

  class HapticCondition < FFI::Struct
    layout(
      :type, :ushort,
      :direction, HapticDirection,
      :length, :uint,
      :delay, :ushort,
      :button, :ushort,
      :interval, :ushort,
      :right_sat, [:ushort, 3],
      :left_sat, [:ushort, 3],
      :right_coeff, [:short, 3],
      :left_coeff, [:short, 3],
      :deadband, [:ushort, 3],
      :center, [:short, 3],
    )
  end

  class HapticRamp < FFI::Struct
    layout(
      :type, :ushort,
      :direction, HapticDirection,
      :length, :uint,
      :delay, :ushort,
      :button, :ushort,
      :interval, :ushort,
      :start, :short,
      :end, :short,
      :attack_length, :ushort,
      :attack_level, :ushort,
      :fade_length, :ushort,
      :fade_level, :ushort,
    )
  end

  class HapticLeftRight < FFI::Struct
    layout(
      :type, :ushort,
      :length, :uint,
      :large_magnitude, :ushort,
      :small_magnitude, :ushort,
    )
  end

  class HapticCustom < FFI::Struct
    layout(
      :type, :ushort,
      :direction, HapticDirection,
      :length, :uint,
      :delay, :ushort,
      :button, :ushort,
      :interval, :ushort,
      :channels, :uchar,
      :period, :ushort,
      :samples, :ushort,
      :data, :pointer,
      :attack_length, :ushort,
      :attack_level, :ushort,
      :fade_length, :ushort,
      :fade_level, :ushort,
    )
  end

  class HapticEffect < FFI::Union
    layout(
      :type, :ushort,
      :constant, HapticConstant,
      :periodic, HapticPeriodic,
      :condition, HapticCondition,
      :ramp, HapticRamp,
      :leftright, HapticLeftRight,
      :custom, HapticCustom,
    )
  end


  # Function

  def self.setup_haptic_symbols(output_error = false)
    entries = [
      [:GetHaptics, :SDL_GetHaptics, [:pointer], :pointer],
      [:GetHapticNameForID, :SDL_GetHapticNameForID, [:uint], :pointer],
      [:OpenHaptic, :SDL_OpenHaptic, [:uint], :pointer],
      [:GetHapticFromID, :SDL_GetHapticFromID, [:uint], :pointer],
      [:GetHapticID, :SDL_GetHapticID, [:pointer], :uint],
      [:GetHapticName, :SDL_GetHapticName, [:pointer], :pointer],
      [:IsMouseHaptic, :SDL_IsMouseHaptic, [], :bool],
      [:OpenHapticFromMouse, :SDL_OpenHapticFromMouse, [], :pointer],
      [:IsJoystickHaptic, :SDL_IsJoystickHaptic, [:pointer], :bool],
      [:OpenHapticFromJoystick, :SDL_OpenHapticFromJoystick, [:pointer], :pointer],
      [:CloseHaptic, :SDL_CloseHaptic, [:pointer], :void],
      [:GetMaxHapticEffects, :SDL_GetMaxHapticEffects, [:pointer], :int],
      [:GetMaxHapticEffectsPlaying, :SDL_GetMaxHapticEffectsPlaying, [:pointer], :int],
      [:GetHapticFeatures, :SDL_GetHapticFeatures, [:pointer], :uint],
      [:GetNumHapticAxes, :SDL_GetNumHapticAxes, [:pointer], :int],
      [:HapticEffectSupported, :SDL_HapticEffectSupported, [:pointer, :pointer], :bool],
      [:CreateHapticEffect, :SDL_CreateHapticEffect, [:pointer, :pointer], :int],
      [:UpdateHapticEffect, :SDL_UpdateHapticEffect, [:pointer, :int, :pointer], :bool],
      [:RunHapticEffect, :SDL_RunHapticEffect, [:pointer, :int, :uint], :bool],
      [:StopHapticEffect, :SDL_StopHapticEffect, [:pointer, :int], :bool],
      [:DestroyHapticEffect, :SDL_DestroyHapticEffect, [:pointer, :int], :void],
      [:GetHapticEffectStatus, :SDL_GetHapticEffectStatus, [:pointer, :int], :bool],
      [:SetHapticGain, :SDL_SetHapticGain, [:pointer, :int], :bool],
      [:SetHapticAutocenter, :SDL_SetHapticAutocenter, [:pointer, :int], :bool],
      [:PauseHaptic, :SDL_PauseHaptic, [:pointer], :bool],
      [:ResumeHaptic, :SDL_ResumeHaptic, [:pointer], :bool],
      [:StopHapticEffects, :SDL_StopHapticEffects, [:pointer], :bool],
      [:HapticRumbleSupported, :SDL_HapticRumbleSupported, [:pointer], :bool],
      [:InitHapticRumble, :SDL_InitHapticRumble, [:pointer], :bool],
      [:PlayHapticRumble, :SDL_PlayHapticRumble, [:pointer, :float, :uint], :bool],
      [:StopHapticRumble, :SDL_StopHapticRumble, [:pointer], :bool],
    ]
    entries.each do |entry|
      attach_function entry[0], entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})." if output_error
    end
  end

end

