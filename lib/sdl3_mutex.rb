# Ruby-SDL3 : SDL3 wrapper for Ruby
#
# * https://github.com/vaiorabbit/sdl3-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module SDL
  extend FFI::Library
  # Define/Macro


  # Enum

  INIT_STATUS_UNINITIALIZED = 0
  INIT_STATUS_INITIALIZING = 1
  INIT_STATUS_INITIALIZED = 2
  INIT_STATUS_UNINITIALIZING = 3

  # Typedef

  typedef :int, :SDL_InitStatus

  # Struct

  class InitState < FFI::Struct
    layout(
      :status, AtomicInt,
      :thread, :ulong_long,
      :reserved, :pointer,
    )
  end


  # Function

  def self.setup_mutex_symbols(output_error = false)
    entries = [
      [:CreateMutex, :SDL_CreateMutex, [], :pointer],
      [:LockMutex, :SDL_LockMutex, [:pointer], :void],
      [:TryLockMutex, :SDL_TryLockMutex, [:pointer], :bool],
      [:UnlockMutex, :SDL_UnlockMutex, [:pointer], :void],
      [:DestroyMutex, :SDL_DestroyMutex, [:pointer], :void],
      [:CreateRWLock, :SDL_CreateRWLock, [], :pointer],
      [:LockRWLockForReading, :SDL_LockRWLockForReading, [:pointer], :void],
      [:LockRWLockForWriting, :SDL_LockRWLockForWriting, [:pointer], :void],
      [:TryLockRWLockForReading, :SDL_TryLockRWLockForReading, [:pointer], :bool],
      [:TryLockRWLockForWriting, :SDL_TryLockRWLockForWriting, [:pointer], :bool],
      [:UnlockRWLock, :SDL_UnlockRWLock, [:pointer], :void],
      [:DestroyRWLock, :SDL_DestroyRWLock, [:pointer], :void],
      [:CreateSemaphore, :SDL_CreateSemaphore, [:uint], :pointer],
      [:DestroySemaphore, :SDL_DestroySemaphore, [:pointer], :void],
      [:WaitSemaphore, :SDL_WaitSemaphore, [:pointer], :void],
      [:TryWaitSemaphore, :SDL_TryWaitSemaphore, [:pointer], :bool],
      [:WaitSemaphoreTimeout, :SDL_WaitSemaphoreTimeout, [:pointer, :int], :bool],
      [:SignalSemaphore, :SDL_SignalSemaphore, [:pointer], :void],
      [:GetSemaphoreValue, :SDL_GetSemaphoreValue, [:pointer], :uint],
      [:CreateCondition, :SDL_CreateCondition, [], :pointer],
      [:DestroyCondition, :SDL_DestroyCondition, [:pointer], :void],
      [:SignalCondition, :SDL_SignalCondition, [:pointer], :void],
      [:BroadcastCondition, :SDL_BroadcastCondition, [:pointer], :void],
      [:WaitCondition, :SDL_WaitCondition, [:pointer, :pointer], :void],
      [:WaitConditionTimeout, :SDL_WaitConditionTimeout, [:pointer, :pointer, :int], :bool],
      [:ShouldInit, :SDL_ShouldInit, [:pointer], :bool],
      [:ShouldQuit, :SDL_ShouldQuit, [:pointer], :bool],
      [:SetInitialized, :SDL_SetInitialized, [:pointer, :bool], :void],
    ]
    entries.each do |entry|
      attach_function entry[0], entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})." if output_error
    end
  end

end

